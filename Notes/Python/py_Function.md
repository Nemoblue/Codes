# Python Function

## 函数

函数简介

- 函数是一个对象

- 创建函数：
    ```
    def 函数名([形参1,形参2,...形参n]) :
        代码块
    ```
    - 函数名必须要符号标识符的规范（可以包含字母、数字、下划线、但是不能以数字开头）

- 调用函数：`函数对象()`

---

函数参数

- `形参`（形式参数），定义形参就相当于在函数内部声明了变量，但是并不赋值

- `实参`（实际参数），如果函数定义时，指定了形参，那么在调用函数时也必须传递实参，实参将会赋值给对应的形参

- 定义形参时，可以为形参指定默认值
    ```
    def fn(a = 5 , b = 10 , c = 20):
        print('a =',a)
        print('b =',b)
        print('c =',c)

    fn(1 , 2 , 3)   # a = 1 b = 2 c = 3
    fn()    # a = 5 b = 10 c = 20
    ```

- 实参的传递方式
    - `位置参数`：将对应位置的实参复制给对应位置的形参
    - `关键字参数`：可以不按照形参定义的顺序去传递，而直接根据参数名去传递参数
    - 混合使用关键字和位置参数时，必须将位置参数写到前面

        ```
        fn(1 , 2 , 3)   # 位置参数
        fn(b=1 , c=2 , a=3) # 关键字参数

        # 混合参数
        print('hello' , end='')
        fn(1,c=30)
        ```

- 实参的类型
    - 函数在调用时，解析器**不会检查**实参的类型。实参可以传递任意类型的对象
        ```
        def fn2(a):
            print('a =',a)
            a(1, 2, 3)  # a = 1 b = 2 c = 3

        fn2(fn) # a = <function at 0x123>

        def fn3(a , b):
            print(a+b)

        fn3(123,"456")  # Type Error
        ```

    - 在函数中对形参进行重新赋值，不会影响其他的变量（实参）
        ```
        def fn4(a): 
            a = 20
        
        c = 10
        fn4(c)  # c = 10
        ```

    - 如果形参执行的是一个**对象**，当我们通过形参去修改对象时，会影响到所有指向该对象的变量
        ```
        def fn4(a):
            a[0] = 30
            print('a =',a,id(a))
        
        c = [1, 2, 3] 
        # fn4(c)  # c = [30, 2, 3]

        fn4(c.copy())   # c = [1, 2, 3]
        fn4(c[:])   # c = [1, 2, 3]
        # print('c =',c,id(c))
        ```

---

不定长参数

- 在定义函数时，可以在形参前边加上一个 `*`，这样这个形参将会获取到所有剩余的位置实参，并保存到一个**元组**中（装包）
    ```
    def sum(*nums):
        result = 0
        for n in nums :
            result += n
        print(result)
    
    sum(123,456,789,10,20,30,40)
    ```

- 带星号的形参只能有一个，可以和其他参数配合使用

- `*` 形参只能接收位置参数，而不能接收关键字参数

- 可变参数不是必须写在最后，但是带 `*` 的参数后的所有参数，必须以关键字参数的形式传递
    ```
    # 第一个参数给 a，剩下的位置参数作为元组给 b，c 必须使用关键字参数
    def fn2(a, *b, c):
        print('a =',a)
        print('b =',b)
        print('c =',c)
    
    fn2(1, 2, 3, 4, c = 5)

    # 如果在形参的开头直接写一个*,则要求我们的所有的参数必须以关键字参数的形式传递
    def fn2(*, a, b, c):
        print('a =', a)
        print('b =', b)
        print('c =', c)

    fn2(a = 3, b = 4, c = 5)
    ```

- `**` 形参可以接收其他的**关键字参数**，它会将这些参数统一保存到一个字典中
    - 字典的 `key` 就是参数的名字，字典的 `value` 就是参数的值
    - `**` 形参只能有一个，并且必须写在所有参数的**最后**
    ```
    def fn3(b, c, **a) :
        print('a =',a,type(a))
        print('b =',b)
        print('c =',c)

    fn3(b=1,d=2,c=3,e=10,f=20)
    ```

- 参数的解包（拆包）
    - 传递实参时，可以在序列类型的参数前添加星号，这样他会自动将序列中的元素依次作为参数传递
    - 这里要求序列中元素的个数必须和形参的个数的一致
        ```
        def fn4(a, b, c):
            print('a =',a)
            print('b =',b)
            print('c =',c)

        t = (10, 20, 30)
        fn4(*t) 
        ```
    - 通过 `**` 来对一个字典进行解包操作
        ```
        d = {'a':100,'b':200,'c':300}
        fn4(**d)
        ```

---

返回值
- 可以通过 `return` 来指定函数的返回值
    ```
    def fn():
        def fn2() :
            print('hello')

        return fn2 # 返回值也可以是一个函数
    
    r = fn()    # 返回一个函数
    r   # <fuction at 0x123>
    r() # 'hello'

    ```

- 如果仅写一个 `return` 或者不写，则相当于 `return None`
- 在函数中，`return` 后的代码都不会执行，`return` 一旦执行函数自动结束

---

文档字符串

- `help()` 是 Python 中的内置函数，可以查询函数的用法
    - 语法：`help(函数对象)`

    ```
    help(print) # 获取print()函数的使用说明
    ```

- 在定义函数时，可以在函数内部编写文档字符串（`doc str`）作为函数的说明，通过 `help()` 函数来查看函数的说明
    ```
    def fn(a: int, b: bool, c: str = 'hello') -> int:
        '''
        这是一个文档字符串的示例

        函数的作用：
        函数的参数：
            a，作用，类型，默认值
            b，作用，类型，默认值
            c，作用，类型，默认值
        '''
        return 10

    help(fn)
    ```

---

作用域（`scope`）

- 作用域指的是变量生效的区域
    ```
    b = 20 # 全局变量

    def fn():
        a = 10 # a定义在了函数内部，所以他的作用域就是函数内部，函数外部无法访问
    ```

- `全局作用域`
    - 全局作用域在程序执行时创建，在程序执行结束时销毁
    - 所有函数以外的区域都是全局作用域
    - 在全局作用域中定义的变量，都属于全局变量，全局变量可以在程序的任意位置被访问

- `函数作用域`
    - 函数作用域在函数调用时创建，在调用结束时销毁
    - 函数每调用一次就会产生一个新的函数作用域
    - 在函数作用域中定义的变量，都是局部变量，它只能在函数内部被访问   

-  变量的查找
    - 当我们使用变量时，会优先在当前作用域中寻找该变量，如果有则使用
    - 如果没有则继续去上一级作用域中寻找，直到找到全局作用域，依然没有找到，则会抛出异常 

- 如果希望在函数内部修改全局变量，则需要使用 `global` 关键字来声明变量

    ```
    a = 20

    def fn3():
        a = 10 # 默认为局部变量赋值
        global a # 声明在函数内部的 a 是全局变量，此时再去修改 a 就是在修改全局的 a
        a = 10 # 修改全局变量
        print('函数内部：','a =',a) # a = 10

    fn3()
    print('函数外部：','a =',a) # a = 10
    ```

---

命名空间（`namespace`）

- 命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间当中
    - 每一个作用域都会有一个它对应的命名空间
    - 全局命名空间，用来保存全局变量，函数命名空间用来保存函数中的变量
    - 命名空间实际上是一个专门用来存储变量的字典

- `locals()` 用来获取当前作用域的命名空间
    ```
    a = 20
    scope = locals()    # 当前命名空间

    print(type(scope))  # <class 'dict'>
    print(scope['a'])   # 20

    # 向 scope 中添加一个 key-value，相当于在全局中创建了一个变量（不建议）
    scope['c'] = 1000
    ```

- `globals()` 函数可以用来在任意位置获取全局命名空间
    ```
    def fn4():
        a = 10

        # 在函数内部调用 locals() 会获取到函数的命名空间
        scope = locals()
        # 通过 scope 来操作函数的命名空间（不建议）
        scope['b'] = 20 

        global_scope = globals()
        print(global_scope['a'])    # a = 20
        global_scope['a'] = 30  # 修改外部变量（不建议）

    fn4()
    print(a)    # a = 30
    ```

---

## 高阶函数

递归

- 递归式函数的两个条件
    - `基线条件`
        
        问题可以被分解为的最小问题，当满足基线条件时，递归就不再继续执行

    - `递归条件`
        
        将问题继续分解的条件

    ```
    def palindrome(s):
        '''
        该函数用来检查指定的字符串是否回文字符串，如果是返回True，否则返回False

        参数：
            s：检查的字符串
        '''
        # 基线条件
        if len(s) < 2 :
            # 字符串的长度小于2，则字符串一定是回文
            return True
            
        # 递归条件    
        return s[0] == s[-1] and palindrome(s[1:-1])
    ```
---

高阶函数

- 在 Python 中，函数是一等对象

- 一等对象一般都会具有如下特点：
    - 对象是在运行时创建的
    - 能赋值给变量或作为数据结构中的元素
    - 能作为参数传递
    - 能作为返回值返回
    
- 高阶函数至少要符合以下两个特点中的一个
    - 接收一个或多个函数作为参数
    - 将函数作为返回值返回

    ```
    # 创建一个列表
    l = [1,2,3,4,5,6,7,8,9,10]

    # 检查一个任意的数字是否是偶数
    def fn2(i) :
        return i % 2 == 0    

    # 检查指定的数字是否大于5
    def fn3(i):
        return i > 5

    def fn(func, lst) :
        '''
        fn()函数可以将指定列表中的所有满足条件的数获取出来，并保存到一个新列表中返回

        参数：
            lst：要进行筛选的列表
        '''
        # 创建一个新列表
        new_list = []

        # 对列表进行筛选
        for n in lst:
            # 判断条件
            if func(n) :
                new_list.append(n)

        # 返回新列表
        return new_list
    ```

- `filter()` 可以从序列中过滤出符合条件的元素，保存到一个新的序列中
    - 参数：
        - 函数，根据该函数来过滤序列（可迭代的结构）
        - 需要过滤的序列（可迭代的结构）

    - 返回值：过滤后的新序列（可迭代的结构）

    ```
    r = filter(fn3, l)
    print(list(r))
    ```
---

匿名函数

- lambda函数表达式专门用来创建一些简单的函数，一般都是作为参数使用，其他地方一般不会使用

- 语法：`lambda 参数列表 : 返回值`

    ```
    r = filter(lambda i : i > 5 , l)
    print(list(r))
    ```

- `map()` 函数可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回

    ```
    r = map(lambda i : i ** 2 , l)
    print(list(r))
    ```

- `sort()` 用来对列表中的元素进行排序
    - 可以接收一个关键字参数，`key` 
    - 当设置了函数作为参数，每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小

    ```
    l = ['bb', 'aaaa', 'c', 'ddddddddd', 'fff']

    # 根据长度排序
    l.sort(key = len)

    l = [2, 5, '1', 3, '6', '4']

    # 全部转换成整型并比较
    l.sort(key = int)
    ```

- `sorted()` 可以对任意的序列进行排序
    - 使用 `sorted()` 排序不会影响原来的对象，而是返回一个新对象

    ```
    l = [2,5,'1',3,'6','4']

    print(l)    # 保持原序列
    print(sorted(l, key=int))
    ```

---

闭包

- 将函数作为返回值返回，称为闭包，通过闭包可以创建一些只有当前函数能访问的变量

- 可以将一些**私有数据**藏到闭包中，减少全局变量

    ```
    def fn():
        a = 10

        # 函数内部再定义一个函数
        def inner():
            print('fn2: ' , a)

        # 将内部函数 inner作为返回值返回   
        return inner

    # r 是一个函数，是调用 fn() 后返回的函数
    # 这个函数在 fn() 内部定义，并不是全局函数
    # 这个函数总是能访问到 fn() 函数内的变量
    r = fn()    

    r() # fn2: 10
    ```

- 形成闭包的要件
    - 函数嵌套
    - 将内部函数作为返回值返回
    - 内部函数必须要使用到外部函数的变量

    ```
    def make_average():
        # 创建一个私有列表，用来保存数值
        nums = []

        # 创建一个函数，用来计算平均值
        def average(n) :
            # 将n添加到列表中
            nums.append(n)
            # 求平均值
            return sum(nums) / len(nums)

        return average

    average = make_average()

    print(average(10))
    print(average(20))
    print(average(30))
    print(average(40))
    ```

---

装饰器
- 装饰器可以在不修改原来函数的情况下来对函数进行扩展
- 开闭原则（`OCP`）：程序的设计要求开放对程序的扩展，关闭对程序的修改

    ```
    def add(a , b):
        return a + b

    def mul(a , b):
        return a * b  
        
    def begin_end(old):
        '''
        用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，执行后打印执行结束

        参数：
            old 要扩展的函数对象
        '''

        # 创建一个新函数
        def new_function(*args , **kwargs):
            print('Start Execution')

            # 调用被扩展的函数
            result = old(*args, **kwargs)

            print('End Execution')
            
            # 返回函数的执行结果
            return result

        # 返回新函数        
        return new_function

    f2 = begin_end(add)
    f3 = begin_end(mul)
    ```

- 在定义函数时，可以通过 `@` 来使用指定的装饰器装饰当前的函数

- 可以同时为一个函数指定多个装饰器，这样函数将会按照从内向外的顺序被装饰

    ```
    def fn3(old):
        # 创建一个新函数
        def new_function(*args, **kwargs):

            print('fn3 Start')
            result = old(*args, **kwargs)
            print('fn3 End')

            # 返回函数的执行结果
            return result

        # 返回新函数        
        return new_function

    @fn3
    @begin_end
    def say_hello():
        print('Hello')

    '''
    fn3 Start
    Start Execution
    Hello
    End Execution
    fn3 End
    '''
    say_hello()
    ```